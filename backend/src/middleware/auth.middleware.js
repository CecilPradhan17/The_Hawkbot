/**
 * requireAuth.js
 *
 * Purpose:
 * - Provides middleware to protect routes by requiring a valid JWT for access
 *
 * Responsibilities:
 * - Checks for the presence of an Authorization header with a Bearer token
 * - Verifies the JWT using the secret from environment variables
 * - Attaches decoded user information to the request object (`req.user`) if valid
 * - Blocks access and returns 401 Unauthorized if the token is missing, invalid, or expired
 *
 * Used by:
 * - posts.routes.js
 *
 * Function:
 * - requireAuth(req, res, next)
 *   - Parameters:
 *       - req: Express request object
 *       - res: Express response object
 *       - next: Express next middleware function
 *   - Behavior:
 *       - Checks `req.headers.authorization` for a Bearer token
 *       - Verifies the token using `jwt.verify` and `process.env.JWT_SECRET`
 *       - On success, stores decoded token payload (e.g., `{ id, email }`) in `req.user` and calls `next()`
 *       - On failure, responds with 401 status and a relevant error message
 *
 * Security notes:
 * - Ensures that only requests with valid JWTs can access protected resources
 * - Does not expose token verification errors in detail to prevent information leakage
 *
 * Extra notes:
 * - Works with tokens generated by `signToken` in `jwt.js`
 * - Can be used as middleware in Express route definitions like:
 *      `app.get("/protected", requireAuth, handlerFunction)`
 *
 * Additional info for Frontend/Modification:
 * - Frontend must include the JWT in the `Authorization` header as `Bearer <token>` for requests to protected routes
 * - Can be extended to check user roles or permissions in `req.user` for fine-grained access control
 * - Useful for logging, auditing, or passing user info downstream in middleware chains
 */

import jwt from "jsonwebtoken";
import 'dotenv/config';

export const requireAuth = (req, res, next) => {
    const authHeader = req.headers.authorization;

    if (!authHeader || !authHeader.startsWith("Bearer ")) {
        return res.status(401).json({ message: "Unauthorized" });
    }

    const token = authHeader.split(" ")[1];

    try {
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        req.user = decoded; // { id, email }
        next();
    } catch {
        return res.status(401).json({ message: "Invalid or expired token" });
    }
};